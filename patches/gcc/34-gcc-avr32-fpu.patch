diff -Naur ./gcc/config/avr32/avr32.c ./gcc/config/avr32/avr32.c
--- ./gcc/config/avr32/avr32.c	2010-12-02 12:02:06.000000000 -0600
+++ ./gcc/config/avr32/avr32.c	2010-12-02 12:02:34.000000000 -0600
@@ -2301,13 +2301,6 @@
 int
 avr32_hard_regno_mode_ok (int regnr, enum machine_mode mode)
 {
-  /* We allow only float modes in the fp-registers */
-  if (regnr >= FIRST_FP_REGNUM
-      && regnr <= LAST_FP_REGNUM && GET_MODE_CLASS (mode) != MODE_FLOAT)
-    {
-      return 0;
-    }
-
   switch (mode)
     {
       case DImode:		/* long long */
@@ -2411,44 +2404,6 @@
 }
 
 
-/* Compute mask of which floating-point registers needs saving upon
-  entry to this function. */
-static unsigned long
-avr32_compute_save_fp_reg_mask (void)
-{
-  unsigned long func_type = avr32_current_func_type ();
-  unsigned int save_reg_mask = 0;
-  unsigned int reg;
-  unsigned int max_reg = 7;
-  int save_all_call_used_regs = FALSE;
-
-  /* This only applies for hardware floating-point implementation. */
-  if (!TARGET_HARD_FLOAT)
-    return 0;
-
-  if (IS_INTERRUPT (func_type))
-    {
-
-      /* Interrupt functions must not corrupt any registers, even call
-         clobbered ones.  If this is a leaf function we can just examine the
-         registers used by the RTL, but otherwise we have to assume that
-         whatever function is called might clobber anything, and so we have
-         to save all the call-clobbered registers as well. */
-      max_reg = 13;
-      save_all_call_used_regs = !current_function_is_leaf;
-    }
-
-  /* All used registers used must be saved */
-  for (reg = 0; reg <= max_reg; reg++)
-    if (df_regs_ever_live_p (INTERNAL_FP_REGNUM (reg))
-	|| (save_all_call_used_regs
-	    && call_used_regs[INTERNAL_FP_REGNUM (reg)]))
-      save_reg_mask |= (1 << reg);
-
-  return save_reg_mask;
-}
-
-
 /* Compute mask of registers which needs saving upon function entry. */
 static unsigned long
 avr32_compute_save_reg_mask (int push)
@@ -2630,7 +2585,6 @@
 {
   unsigned int func_type = avr32_current_func_type ();
   unsigned long saved_int_regs;
-  unsigned long saved_fp_regs;
 
   /* Never use a return instruction before reload has run. */
   if (!reload_completed)
@@ -2645,12 +2599,6 @@
     return 0;
 
   saved_int_regs = avr32_compute_save_reg_mask (TRUE);
-  saved_fp_regs = avr32_compute_save_fp_reg_mask ();
-
-  /* Functions which have saved fp-regs on the stack can not be performed in
-     one instruction */
-  if (saved_fp_regs)
-    return 0;
 
   /* Conditional returns can not be performed in one instruction if we need
      to restore registers from the stack */
@@ -2811,52 +2759,6 @@
   return insn;
 }
 
-
-static rtx
-emit_multi_fp_reg_push (int reglist)
-{
-  rtx insn;
-  rtx dwarf;
-  rtx tmp;
-  rtx reg;
-  int i;
-  int nr_regs;
-  int index = 0;
-
-  insn = emit_insn (gen_stm_fp (stack_pointer_rtx,
-				gen_rtx_CONST_INT (SImode, reglist),
-				gen_rtx_CONST_INT (SImode, 1)));
-
-  nr_regs = avr32_get_reg_mask_size (reglist) / 4;
-  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (nr_regs + 1));
-
-  for (i = 15; i >= 0; i--)
-    {
-      if (reglist & (1 << i))
-	{
-	  reg = gen_rtx_REG (SImode, INTERNAL_FP_REGNUM (i));
-	  tmp = gen_rtx_SET (VOIDmode,
-			     gen_rtx_MEM (SImode,
-					  plus_constant (stack_pointer_rtx,
-							 4 * index)), reg);
-	  RTX_FRAME_RELATED_P (tmp) = 1;
-	  XVECEXP (dwarf, 0, 1 + index++) = tmp;
-	}
-    }
-
-  tmp = gen_rtx_SET (SImode,
-		     stack_pointer_rtx,
-		     gen_rtx_PLUS (SImode,
-				   stack_pointer_rtx,
-				   GEN_INT (-4 * nr_regs)));
-  RTX_FRAME_RELATED_P (tmp) = 1;
-  XVECEXP (dwarf, 0, 0) = tmp;
-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
-					REG_NOTES (insn));
-  return insn;
-}
-
-
 rtx
 avr32_gen_load_multiple (rtx * regs, int count, rtx from,
 			 int write_back, int in_struct_p, int scalar_p)
@@ -3015,7 +2917,7 @@
 avr32_expand_prologue (void)
 {
   rtx insn, dwarf;
-  unsigned long saved_reg_mask, saved_fp_reg_mask;
+  unsigned long saved_reg_mask;
   int reglist8 = 0;
 
   /* Naked functions do not have a prologue. */
@@ -3114,17 +3016,6 @@
       emit_insn (gen_blockage ());
     }
 
-  saved_fp_reg_mask = avr32_compute_save_fp_reg_mask ();
-  if (saved_fp_reg_mask)
-    {
-      insn = emit_multi_fp_reg_push (saved_fp_reg_mask);
-      RTX_FRAME_RELATED_P (insn) = 1;
-
-      /* Prevent this instruction from being scheduled after any other
-         instructions.  */
-      emit_insn (gen_blockage ());
-    }
-
   /* Set frame pointer */
   if (frame_pointer_needed)
     {
@@ -3270,7 +3161,7 @@
 				 rtx cond ATTRIBUTE_UNUSED, rtx r12_imm)
 {
 
-  unsigned long saved_reg_mask, saved_fp_reg_mask;
+  unsigned long saved_reg_mask;
   int insert_ret = TRUE;
   int reglist8 = 0;
   int stack_adjustment = get_frame_size ();
@@ -3281,8 +3172,6 @@
   if (IS_NAKED (func_type))
     return;
 
-  saved_fp_reg_mask = avr32_compute_save_fp_reg_mask ();
-
   saved_reg_mask = avr32_compute_save_reg_mask (FALSE);
 
   /* Reset frame pointer */
@@ -3304,19 +3193,6 @@
 	}
     }
 
-  if (saved_fp_reg_mask)
-    {
-      char reglist[64];		/* 64 bytes should be enough... */
-      avr32_make_fp_reglist_w (saved_fp_reg_mask, (char *) reglist);
-      fprintf (f, "\tldcm.w\tcp0, sp++, %s\n", reglist);
-      if (saved_fp_reg_mask & ~0xff)
-	{
-	  saved_fp_reg_mask &= ~0xff;
-	  avr32_make_fp_reglist_d (saved_fp_reg_mask, (char *) reglist);
-	  fprintf (f, "\tldcm.d\tcp0, sp++, %s\n", reglist);
-	}
-    }
-
   if (saved_reg_mask)
     {
       /* Must pop used registers */
@@ -3457,55 +3333,6 @@
     }
 }
 
-
-/* Function for converting a fp-register mask to a
-   reglistCPD8 register list string. */
-void
-avr32_make_fp_reglist_d (int reglist_mask, char *reglist_string)
-{
-  int i;
-
-  /* Make sure reglist_string is empty */
-  reglist_string[0] = '\0';
-
-  for (i = 0; i < NUM_FP_REGS; i += 2)
-    {
-      if (reglist_mask & (1 << i))
-	{
-	  if (strlen (reglist_string))
-            { 
-  	      strcat (reglist_string, ", ");
-	    }
-          strcat (reglist_string,reg_names[INTERNAL_FP_REGNUM (i)]);
-	  strcat (reglist_string, "-");
-	  strcat (reglist_string,reg_names[INTERNAL_FP_REGNUM (i + 1)]);
-	}
-    }
-}
-
-
-/* Function for converting a fp-register mask to a
-   reglistCP8 register list string. */
-void
-avr32_make_fp_reglist_w (int reglist_mask, char *reglist_string)
-{
-  int i;
-
-  /* Make sure reglist_string is empty. */
-  reglist_string[0] = '\0';
-
-  for (i = 0; i < NUM_FP_REGS; ++i)
-    {
-      if (reglist_mask & (1 << i))
-	{
-	  if (strlen (reglist_string))
-	      strcat(reglist_string, ", ");
-          strcat (reglist_string, reg_names[INTERNAL_FP_REGNUM (i)]);
-	}
-    }
-}
-
-
 void
 avr32_make_reglist16 (int reglist16_vect, char *reglist16_string)
 {
@@ -3524,7 +3351,6 @@
     }
 }
 
-
 int
 avr32_convert_to_reglist16 (int reglist8_vect)
 {
@@ -3549,7 +3375,6 @@
   return reglist16_vect;
 }
 
-
 void
 avr32_make_reglist8 (int reglist8_vect, char *reglist8_string)
 {
@@ -3635,11 +3460,10 @@
 {
   int i;
   int call_saved_regs = 0;
-  unsigned long saved_reg_mask, saved_fp_reg_mask;
+  unsigned long saved_reg_mask;
   unsigned int local_vars = get_frame_size ();
 
   saved_reg_mask = avr32_compute_save_reg_mask (TRUE);
-  saved_fp_reg_mask = avr32_compute_save_fp_reg_mask ();
 
   for (i = 0; i < 16; ++i)
     {
@@ -3647,12 +3471,6 @@
 	call_saved_regs += 4;
     }
 
-  for (i = 0; i < NUM_FP_REGS; ++i)
-    {
-      if (saved_fp_reg_mask & (1 << i))
-	call_saved_regs += 4;
-    }
-
   switch (from)
     {
     case ARG_POINTER_REGNUM:
@@ -4231,10 +4049,6 @@
   /* Standard coprocessor addressing modes.  */
   if (code == CONST_INT)
     {
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
-	/* Coprocessor mem insns has a smaller reach than ordinary mem insns */
-	return CONST_OK_FOR_CONSTRAINT_P (INTVAL (index), 'K', "Ku14");
-      else
 	return CONST_OK_FOR_CONSTRAINT_P (INTVAL (index), 'K', "Ks16");
     }
 
@@ -4679,7 +4493,6 @@
     {
     case CC_CALL_SET:
       CC_STATUS_INIT;
-      FPCC_STATUS_INIT;
       /* Check if the function call returns a value in r12 */
       if (REG_P (recog_data.operand[0])
 	  && REGNO (recog_data.operand[0]) == RETVAL_REGNUM)
@@ -4804,26 +4617,6 @@
 
       }
       break;
-    case CC_FPCOMPARE:
-      /* Check that floating-point compare will not be optimized away if so
-         nothing should be done */
-      if (!rtx_equal_p (cc_prev_status.mdep.fpvalue, SET_SRC (exp)))
-	{
-	  /* cc0 already contains the correct comparison -> delete cmp insn */
-	  /* Reset the nonstandard flag */
-	  cc_status.mdep.fpvalue = SET_SRC (exp);
-	  cc_status.mdep.fpflags = CC_SET_CZ;
-	}
-      break;
-    case CC_FROM_FPCC:
-      /* Flags are updated with flags from Floating-point coprocessor, set
-         CC_NOT_SIGNED flag since the flags are set so that unsigned
-         condidion codes can be used directly. */
-      CC_STATUS_INIT;
-      cc_status.flags = CC_NOT_SIGNED;
-      cc_status.mdep.value = cc_status.mdep.fpvalue;
-      cc_status.mdep.flags = cc_status.mdep.fpflags;
-      break;
     case CC_BLD:
       /* Bit load is kind of like an inverted testsi, because the Z flag is
          inverted */
@@ -5163,22 +4956,6 @@
 	      fputs (reglist16_string, stream);
 	      return;
 	    }
-	  case 'C':
-	    {
-	      /* RegListCP8 */
-	      char reglist_string[100];
-	      avr32_make_fp_reglist_w (value, (char *) reglist_string);
-	      fputs (reglist_string, stream);
-	      return;
-	    }
-	  case 'D':
-	    {
-	      /* RegListCPD8 */
-	      char reglist_string[100];
-	      avr32_make_fp_reglist_d (value, (char *) reglist_string);
-	      fputs (reglist_string, stream);
-	      return;
-	    }
 	  case 'h':
 	    /* Print halfword part of word */
 	    fputs (value ? "b" : "t", stream);
@@ -5466,7 +5243,6 @@
     }
 }
 
-
 rtx
 avr32_get_note_reg_equiv (rtx insn)
 {
@@ -6426,16 +6202,6 @@
   else if (GET_CODE (body) == SET
            && GET_MODE_SIZE (GET_MODE (SET_DEST (body))) == 4)
     {
-        /* Word Load */
-      if (TARGET_HARD_FLOAT
-          && GET_MODE_CLASS (GET_MODE (SET_DEST (body))) == MODE_FLOAT)
-        {
-          /* Ldc0.w : Ku12 << 2 */
-          fix->forwards = ((1 << 12) - 1) << 2;
-          fix->backwards = 0;
-        }
-      else
-        {
           if (optimize_size)
             {
               /* Lddpc : Ku7 << 2 */
@@ -6449,25 +6215,13 @@
               fix->backwards = (1 << 15);
             }
         }
-    }
   else if (GET_CODE (body) == SET
            && GET_MODE_SIZE (GET_MODE (SET_DEST (body))) == 8)
     {
-      /* Double word load */
-      if (TARGET_HARD_FLOAT
-          && GET_MODE_CLASS (GET_MODE (SET_DEST (body))) == MODE_FLOAT)
-        {
-          /* Ldc0.d : Ku12 << 2 */
-          fix->forwards = ((1 << 12) - 1) << 2;
-          fix->backwards = 0;
-        }
-      else
-        {
           /* Ld.d : Ks16 */
           fix->forwards = ((1 << 15) - 4);
           fix->backwards = (1 << 15);
         }
-    }
   else if (GET_CODE (body) == UNSPEC_VOLATILE
            && XINT (body, 1) == VUNSPEC_MVRC)
     {
diff -Naur ./gcc/config/avr32/avr32.h ./gcc/config/avr32/avr32.h
--- ./gcc/config/avr32/avr32.h	2010-12-02 12:02:06.000000000 -0600
+++ ./gcc/config/avr32/avr32.h	2010-12-02 12:02:34.000000000 -0600
@@ -728,12 +728,10 @@
 /* Convert from gcc internal register number to register number
    used in assembly code */
 #define ASM_REGNUM(reg) (LAST_REGNUM - (reg))
-#define ASM_FP_REGNUM(reg) (LAST_FP_REGNUM - (reg))
 
 /* Convert between register number used in assembly to gcc
    internal register number  */
 #define INTERNAL_REGNUM(reg) (LAST_REGNUM - (reg))
-#define INTERNAL_FP_REGNUM(reg) (LAST_FP_REGNUM - (reg))
 
 /** Basic Characteristics of Registers **/
 
@@ -743,13 +741,10 @@
 pseudo register's number really is assigned the number
 FIRST_PSEUDO_REGISTER.
 */
-#define FIRST_PSEUDO_REGISTER (LAST_FP_REGNUM + 1)
+#define FIRST_PSEUDO_REGISTER (LAST_REGNUM + 1)
 
 #define FIRST_REGNUM 0
 #define LAST_REGNUM 15
-#define NUM_FP_REGS 16
-#define FIRST_FP_REGNUM 16
-#define LAST_FP_REGNUM (16+NUM_FP_REGS-1)
 
 /*
 An initializer that says which registers are used for fixed purposes
@@ -796,22 +791,6 @@
   0, /* r2 */			\
   0, /* r1 */			\
   0, /* r0 */			\
-  0, /* f15 */			\
-  0, /* f14 */			\
-  0, /* f13 */			\
-  0, /* f12 */			\
-  0, /* f11 */			\
-  0, /* f10 */			\
-  0, /* f9 */			\
-  0, /* f8 */			\
-  0, /* f7 */			\
-  0, /* f6 */			\
-  0, /* f5 */			\
-  0, /* f4 */			\
-  0, /* f3 */			\
-  0, /* f2*/			\
-  0, /* f1 */			\
-  0  /* f0 */			\
 }
 
 /*
@@ -842,22 +821,6 @@
   0, /* r2 */			\
   0, /* r1 */			\
   0, /* r0 */			\
-  1, /* f15 */			\
-  1, /* f14 */			\
-  1, /* f13 */			\
-  1, /* f12 */			\
-  1, /* f11 */			\
-  1, /* f10 */			\
-  1, /* f9 */			\
-  1, /* f8 */			\
-  0, /* f7 */			\
-  0, /* f6 */			\
-  0, /* f5 */			\
-  0, /* f4 */			\
-  0, /* f3 */			\
-  0, /* f2*/			\
-  0, /* f1*/			\
-  0, /* f0 */			\
 }
 
 /* Interrupt functions can only use registers that have already been
@@ -901,14 +864,6 @@
 #define CONDITIONAL_REGISTER_USAGE                              \
   do								\
     {								\
-      int regno;						\
-								\
-      if (TARGET_SOFT_FLOAT)			                \
-	{							\
-	  for (regno = FIRST_FP_REGNUM;				\
-	       regno <= LAST_FP_REGNUM; ++regno)	        \
-	    fixed_regs[regno] = call_used_regs[regno] = 1;	\
-	}							\
       if (flag_pic)						\
 	{							\
 	  fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;		\
@@ -958,22 +913,6 @@
   INTERNAL_REGNUM(2),		\
   INTERNAL_REGNUM(1),		\
   INTERNAL_REGNUM(0),		\
-  INTERNAL_FP_REGNUM(15),	\
-  INTERNAL_FP_REGNUM(14),	\
-  INTERNAL_FP_REGNUM(13),	\
-  INTERNAL_FP_REGNUM(12),	\
-  INTERNAL_FP_REGNUM(11),	\
-  INTERNAL_FP_REGNUM(10),	\
-  INTERNAL_FP_REGNUM(9),	\
-  INTERNAL_FP_REGNUM(8),	\
-  INTERNAL_FP_REGNUM(7),	\
-  INTERNAL_FP_REGNUM(6),	\
-  INTERNAL_FP_REGNUM(5),	\
-  INTERNAL_FP_REGNUM(4),	\
-  INTERNAL_FP_REGNUM(3),	\
-  INTERNAL_FP_REGNUM(2),	\
-  INTERNAL_FP_REGNUM(1),	\
-  INTERNAL_FP_REGNUM(0),	\
   SP_REGNUM,           		\
   PC_REGNUM			\
 }
@@ -1094,7 +1033,6 @@
 {
   NO_REGS,
   GENERAL_REGS,
-  FP_REGS,
   ALL_REGS,
   LIM_REG_CLASSES
 };
@@ -1113,7 +1051,6 @@
 {				\
   "NO_REGS",			\
   "GENERAL_REGS",		\
-  "FLOATING_POINT_REGS",	\
   "ALL_REGS"			\
 }
 
@@ -1134,7 +1071,6 @@
 #define REG_CLASS_CONTENTS {		\
   {0x00000000}, /* NO_REGS */		\
   {0x0000FFFF}, /* GENERAL_REGS */	\
-  {0xFFFF0000}, /* FP_REGS */		\
   {0x7FFFFFFF}, /* ALL_REGS */		\
 }
 
@@ -1145,7 +1081,7 @@
 which is minimal, meaning that no smaller class also contains the
 register.
 */
-#define REGNO_REG_CLASS(REGNO) ((REGNO < 16) ? GENERAL_REGS : FP_REGS)
+#define REGNO_REG_CLASS(REGNO) (GENERAL_REGS)
 
 /*
 A macro whose definition is the name of the class to which a valid
@@ -1178,8 +1114,7 @@
 corresponding to class GENERAL_REGS, will not be passed
 to this macro; you do not need to handle it.
 */
-#define REG_CLASS_FROM_LETTER(CHAR) ((CHAR) == 'f' ? FP_REGS : NO_REGS)
-
+#define REG_CLASS_FROM_LETTER(CHAR) NO_REGS
 
 /* These assume that REGNO is a hard or pseudo reg number.
    They give nonzero only if REGNO is a hard reg of the suitable class
@@ -1461,8 +1396,6 @@
 */
 #define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LR_REGNUM)
 
-
-
 /*
 A C expression whose value is an integer giving the offset, in bytes,
 from the value of the stack pointer register to the top of the stack
@@ -1587,8 +1520,6 @@
 /* Use r7 */
 #define FRAME_POINTER_REGNUM INTERNAL_REGNUM(7)
 
-
-
 /*
 The register number of the arg pointer register, which is used to access
 the function's argument list.  On some machines, this is the same as the
@@ -1619,7 +1550,6 @@
 /* Using r0 */
 #define STATIC_CHAIN_REGNUM INTERNAL_REGNUM(0)
 
-
 /** Eliminating Frame Pointer and Arg Pointer **/
 
 /*
@@ -1725,7 +1655,6 @@
 */
 #define PUSH_ARGS 1
 
-
 /*
 A C expression that is the number of bytes actually pushed onto the
 stack when an instruction attempts to push NPUSHED bytes.
@@ -1754,9 +1683,6 @@
 */
 #define ACCUMULATE_OUTGOING_ARGS 0
 
-
-
-
 /*
 A C expression that should indicate the number of bytes of its own
 arguments that a function pops on returning, or 0 if the
@@ -1873,9 +1799,6 @@
 #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
   avr32_function_arg(&(CUM), MODE, TYPE, NAMED)
 
-
-
-
 /*
 A C type for declaring a variable that is used as the first argument of
 FUNCTION_ARG and other related values.  For some target machines,
@@ -1923,7 +1846,6 @@
   while (0)
 #define SET_INDEXES_UNUSED(CUM) ((CUM)->used_index = 0)
 
-
 /*
    A C statement (sans semicolon) for initializing the variable cum for the
    state at the beginning of the argument list. The variable has type
@@ -1945,7 +1867,6 @@
 #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
   avr32_init_cumulative_args(&(CUM), FNTYPE, LIBNAME, FNDECL)
 
-
 /*
 A C statement (sans semicolon) to update the summarizer variable
 CUM to advance past an argument in the argument list.  The
@@ -2000,7 +1921,6 @@
 #define PAD_VARARGS_DOWN \
   (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)
 
-
 /*
 A C expression that is nonzero if REGNO is the number of a hard
 register in which function arguments are sometimes passed.  This does
@@ -2031,7 +1951,6 @@
 /* AVR32 is using r12 as return register. */
 #define RET_REGISTER (15 - 12)
 
-
 /*
 A C expression to create an RTX representing the place where a library
 function returns a value of mode MODE.  If the precise function
@@ -2390,8 +2309,6 @@
 {
   int flags;
   rtx value;
-  int fpflags;
-  rtx fpvalue;
   int cond_exec_cmp_clobbered;
 } avr32_status_reg;
 
@@ -2410,9 +2327,6 @@
 #define CC_STATUS_MDEP_INIT  \
    (cc_status.mdep.flags = CC_NONE , cc_status.mdep.cond_exec_cmp_clobbered = 0, cc_status.mdep.value = 0)
 
-#define FPCC_STATUS_INIT \
-   (cc_status.mdep.fpflags = CC_NONE , cc_status.mdep.fpvalue = 0)
-
 /*
 A C compound statement to set the components of cc_status
 appropriately for an insn INSN whose body is EXP.  It is
@@ -2964,14 +2878,6 @@
   "r5",  "r4",		\
   "r3",  "r2",		\
   "r1",  "r0",		\
-  "f15","f14",		\
-  "f13","f12",		\
-  "f11","f10",		\
-  "f9", "f8",		\
-  "f7", "f6",		\
-  "f5", "f4",		\
-  "f3", "f2",		\
-  "f1", "f0"		\
 }
 
 /*
diff -Naur ./gcc/config/avr32/avr32.md ./gcc/config/avr32/avr32.md
--- ./gcc/config/avr32/avr32.md	2010-12-02 12:02:06.000000000 -0600
+++ ./gcc/config/avr32/avr32.md	2010-12-02 12:02:34.000000000 -0600
@@ -54,7 +54,7 @@
    (UNSPEC_PIC_BASE             11)
    (UNSPEC_STORE_MULTIPLE       12)
    (UNSPEC_STMFP                13)
-   (UNSPEC_FPCC_TO_REG          14)
+   (UNSPEC_FRCPA                14)
    (UNSPEC_REG_TO_CC            15)
    (UNSPEC_FORCE_MINIPOOL       16)
    (UNSPEC_SATS                 17)
@@ -901,8 +901,7 @@
 (define_insn_and_split "*movdf_internal"
   [(set (match_operand:DF 0 "nonimmediate_operand"     "=r,r,r,r,m")
 	(match_operand:DF 1 "general_operand"          " r,G,F,m,r"))]
-  "TARGET_SOFT_FLOAT
-   && (register_operand (operands[0], DFmode)
+  "(register_operand (operands[0], DFmode)
        || register_operand (operands[1], DFmode))"
   {
     switch (which_alternative ){
@@ -921,8 +920,7 @@
       abort();
     }
   }
-  "TARGET_SOFT_FLOAT
-   && reload_completed
+  "reload_completed
    && (REG_P (operands[0]) 
         && (REG_P (operands[1])
             || GET_CODE (operands[1]) == CONST_DOUBLE))"
@@ -2161,6 +2159,7 @@
 ;;-----------------------------------------------------------------------------
 ;; Signed division that produces both a quotient and a remainder.
 ;;=============================================================================
+
 (define_expand "divmodsi4"
   [(parallel [
      (parallel [
@@ -2175,16 +2174,13 @@
   {
     if (can_create_pseudo_p ()) {
       operands[4] = gen_reg_rtx (DImode);
-
       emit_insn(gen_divmodsi4_internal(operands[4],operands[1],operands[2]));
       emit_move_insn(operands[0], gen_rtx_SUBREG( SImode, operands[4], 4));
       emit_move_insn(operands[3], gen_rtx_SUBREG( SImode, operands[4], 0));
-
       DONE;
     } else {
       FAIL;
     }
-
   })
 
 
@@ -2410,6 +2406,26 @@
   [(set_attr "length" "4")
    (set_attr "cc" "compare")])
 
+(define_expand "cmpsf"
+  [(set (cc0)
+	(compare:SF
+	 (match_operand:SF 0 "general_operand" "")
+	 (match_operand:SF 1 "general_operand"  "")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "{
+   rtx tmpreg;
+   if ( !REG_P(operands[0]) )
+     operands[0] = force_reg(SFmode, operands[0]);
+
+   if ( !REG_P(operands[1]) )
+     operands[1] = force_reg(SFmode, operands[1]);
+
+   avr32_compare_op0 = operands[0];
+   avr32_compare_op1 = operands[1];
+   emit_insn(gen_cmpsf_internal_uc3fp(operands[0], operands[1]));
+   DONE;
+  }"
+)
 
 ;;;=============================================================================
 ;; Test if zero
@@ -4938,5 +4954,5 @@
 ;; Load the SIMD description
 (include "simd.md")
 
-;; Load the FP coprAocessor patterns
-(include "fpcp.md")
+;; Include the FPU for uc3
+(include "uc3fpu.md")
diff -Naur ./gcc/config/avr32/avr32-protos.h ./gcc/config/avr32/avr32-protos.h
--- ./gcc/config/avr32/avr32-protos.h	2010-12-02 11:51:18.000000000 -0600
+++ ./gcc/config/avr32/avr32-protos.h	2010-12-02 12:02:34.000000000 -0600
@@ -191,5 +191,6 @@
                                        rtx operands[]);
 
 bool avr32_flashvault_call(tree decl);
+extern void avr32_emit_swdivsf (rtx, rtx, rtx);
 
 #endif /* AVR32_PROTOS_H */
diff -Naur ./gcc/config/avr32/fpcp.md ./gcc/config/avr32/fpcp.md
--- ./gcc/config/avr32/fpcp.md	2010-12-02 11:51:18.000000000 -0600
+++ ./gcc/config/avr32/fpcp.md	1969-12-31 18:00:00.000000000 -0600
@@ -1,551 +0,0 @@
-;;   AVR32 machine description file for Floating-Point instructions.
-;;   Copyright 2003-2006 Atmel Corporation.
-;;
-;;   Written by Ronny Pedersen, Atmel Norway, <rpedersen@atmel.com>
-;;
-;;   This file is part of GCC.
-;;
-;;   This program is free software; you can redistribute it and/or modify
-;;   it under the terms of the GNU General Public License as published by
-;;   the Free Software Foundation; either version 2 of the License, or
-;;   (at your option) any later version.
-;;
-;;   This program is distributed in the hope that it will be useful,
-;;   but WITHOUT ANY WARRANTY; without even the implied warranty of
-;;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-;;   GNU General Public License for more details.
-;;
-;;   You should have received a copy of the GNU General Public License
-;;   along with this program; if not, write to the Free Software
-;;   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-
-;; -*- Mode: Scheme -*-
-
-;;******************************************************************************
-;; Automaton pipeline description for floating-point coprocessor insns
-;;******************************************************************************
-(define_cpu_unit "fid,fm1,fm2,fm3,fm4,fwb,fcmp,fcast" "avr32_ap")
-
-(define_insn_reservation "fmv_op" 1
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fmv"))
-  "is,da,d,fid,fwb")
-
-(define_insn_reservation "fmul_op" 5
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fmul"))
-  "is,da,d,fid,fm1,fm2,fm3,fm4,fwb")
-
-(define_insn_reservation "fcmps_op" 1
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fcmps"))
-  "is,da,d,fid,fcmp")
-
-(define_insn_reservation "fcmpd_op" 2
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fcmpd"))
-  "is,da,d,fid*2,fcmp")
-
-(define_insn_reservation "fcast_op" 3
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fcast"))
-  "is,da,d,fid,fcmp,fcast,fwb")
-
-(define_insn_reservation "fmvcpu_op" 2
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fmvcpu"))
-  "is,da,d")
-
-(define_insn_reservation "fldd_op" 1
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fldd"))
-  "is,da,d,fwb")
-
-(define_insn_reservation "flds_op" 1
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "flds"))
-  "is,da,d,fwb")
-
-(define_insn_reservation "fsts_op" 0
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fsts"))
-  "is,da*2,d")
-
-(define_insn_reservation "fstd_op" 0
-  (and (eq_attr "pipeline" "ap")
-       (eq_attr "type" "fstd"))
-  "is,da*2,d")
-
-
-(define_insn "*movsf_fpcp"
-  [(set (match_operand:SF 0 "nonimmediate_operand"     "=f,f,r,f,m,r,r,r,m")
-	(match_operand:SF 1 "general_operand"          " f,r,f,m,f,r,G,m,r"))]
-  "TARGET_HARD_FLOAT"
-  "@
-   fmov.s\t%0, %1
-   fmov.s\t%0, %1
-   fmov.s\t%0, %1
-   fld.s\t%0, %1
-   fst.s\t%0, %1
-   mov\t%0, %1
-   mov\t%0, %1
-   ld.w\t%0, %1
-   st.w\t%0, %1"
-  [(set_attr "length" "4,4,4,4,4,2,4,4,4")
-   (set_attr "type" "fmv,flds,fmvcpu,flds,fsts,alu,alu,load,store")])
-
-(define_insn_and_split "*movdf_fpcp"
-  [(set (match_operand:DF 0 "nonimmediate_operand"     "=f,f,r,f,m,r,r,m")
-	(match_operand:DF 1 "general_operand"          " f,r,f,m,f,r,m,r"))]
-  "TARGET_HARD_FLOAT"
-  "@
-   fmov.d\t%0, %1
-   fmov.d\t%0, %1
-   fmov.d\t%0, %1
-   fld.d\t%0, %1
-   fst.d\t%0, %1
-   mov\t%0, %1\;mov\t%m0, %m1
-   ld.d\t%0, %1
-   st.d\t%0, %1"
-
-  "TARGET_HARD_FLOAT
-   && reload_completed
-   && (REG_P(operands[0]) &&  (REGNO_REG_CLASS(REGNO(operands[0])) == GENERAL_REGS))
-   && (REG_P(operands[1]) &&  (REGNO_REG_CLASS(REGNO(operands[1])) == GENERAL_REGS))"
-  [(set (match_dup 0) (match_dup 1))
-   (set (match_dup 2) (match_dup 3))]
-  "
-   {
-    operands[2] = gen_highpart (SImode, operands[0]);
-    operands[0] = gen_lowpart (SImode, operands[0]);
-    operands[3] = gen_highpart(SImode, operands[1]);
-    operands[1] = gen_lowpart(SImode, operands[1]);
-   }
-  "
-
-  [(set_attr "length" "4,4,4,4,4,4,4,4")
-   (set_attr "type" "fmv,fldd,fmvcpu,fldd,fstd,alu2,load2,store2")])
-
-
-(define_insn "mulsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-		 (match_operand:SF 2 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fmul.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "nmulsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(neg:SF (mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-                         (match_operand:SF 2 "avr32_fp_register_operand" "f"))))]
-  "TARGET_HARD_FLOAT"
-  "fnmul.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_peephole2
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "")
-	(mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "")
-		 (match_operand:SF 2 "avr32_fp_register_operand" "")))
-   (set (match_operand:SF          3 "avr32_fp_register_operand" "")
-	(neg:SF (match_dup 0)))]
-  "TARGET_HARD_FLOAT &&
-   (peep2_reg_dead_p(2, operands[0]) || (REGNO(operands[3]) == REGNO(operands[0])))"
-  [(set (match_dup 3)
-	(neg:SF (mult:SF (match_dup 1)
-			 (match_dup 2))))]
-)
-
-
-(define_insn "macsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(plus:SF (mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-                          (match_operand:SF 2 "avr32_fp_register_operand" "f"))
-                 (match_operand:SF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fmac.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "nmacsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(plus:SF  (neg:SF (mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-                                   (match_operand:SF 2 "avr32_fp_register_operand" "f")))
-                  (match_operand:SF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fnmac.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_peephole2
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "")
-	(mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "")
-		 (match_operand:SF 2 "avr32_fp_register_operand" "")))
-   (set (match_operand:SF          3 "avr32_fp_register_operand" "")
-	(minus:SF
-	 (match_dup 3)
-	 (match_dup 0)))]
-  "TARGET_HARD_FLOAT && peep2_reg_dead_p(2, operands[0])"
-  [(set (match_dup 3)
-	(plus:SF  (neg:SF (mult:SF (match_dup 1)
-                                   (match_dup 2)))
-                  (match_dup 3)))]
-)
-
-
-(define_insn "msubacsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(minus:SF (mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-                           (match_operand:SF 2 "avr32_fp_register_operand" "f"))
-                  (match_operand:SF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fmsc.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_peephole2
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "")
-	(mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "")
-		 (match_operand:SF 2 "avr32_fp_register_operand" "")))
-   (set (match_operand:SF          3 "avr32_fp_register_operand" "")
-	(minus:SF
-	 (match_dup 0)
-	 (match_dup 3)))]
-  "TARGET_HARD_FLOAT && peep2_reg_dead_p(2, operands[0])"
-  [(set (match_dup 3)
-	(minus:SF  (mult:SF (match_dup 1)
-			    (match_dup 2))
-		   (match_dup 3)))]
-)
-
-(define_insn "nmsubacsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(minus:SF  (neg:SF (mult:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-                                    (match_operand:SF 2 "avr32_fp_register_operand" "f")))
-                   (match_operand:SF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fnmsc.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-
-
-(define_insn "addsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(plus:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-		 (match_operand:SF 2 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fadd.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "subsf3"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(minus:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")
-                  (match_operand:SF 2 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fsub.s\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-
-(define_insn "negsf2"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(neg:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fneg.s\t%0, %1"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmv")])
-
-(define_insn "abssf2"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(abs:SF (match_operand:SF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fabs.s\t%0, %1"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmv")])
-
-(define_insn "truncdfsf2"
-  [(set (match_operand:SF          0 "avr32_fp_register_operand" "=f")
-	(float_truncate:SF
-         (match_operand:DF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fcastd.s\t%0, %1"
-  [(set_attr "length" "4")
-   (set_attr "type" "fcast")])
-
-(define_insn "extendsfdf2"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(float_extend:DF
-         (match_operand:SF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fcasts.d\t%0, %1"
-  [(set_attr "length" "4")
-   (set_attr "type" "fcast")])
-
-(define_insn "muldf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-		 (match_operand:DF 2 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fmul.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "nmuldf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(neg:DF (mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-                         (match_operand:DF 2 "avr32_fp_register_operand" "f"))))]
-  "TARGET_HARD_FLOAT"
-  "fnmul.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_peephole2
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "")
-	(mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "")
-		 (match_operand:DF 2 "avr32_fp_register_operand" "")))
-   (set (match_operand:DF          3 "avr32_fp_register_operand" "")
-	(neg:DF (match_dup 0)))]
-  "TARGET_HARD_FLOAT &&
-   (peep2_reg_dead_p(2, operands[0]) || (REGNO(operands[3]) == REGNO(operands[0])))"
-  [(set (match_dup 3)
-	(neg:DF (mult:DF (match_dup 1)
-			 (match_dup 2))))]
-)
-
-(define_insn "macdf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(plus:DF (mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-                          (match_operand:DF 2 "avr32_fp_register_operand" "f"))
-                 (match_operand:DF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fmac.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "msubacdf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(minus:DF (mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-                           (match_operand:DF 2 "avr32_fp_register_operand" "f"))
-                  (match_operand:DF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fmsc.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_peephole2
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "")
-	(mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "")
-		 (match_operand:DF 2 "avr32_fp_register_operand" "")))
-   (set (match_operand:DF          3 "avr32_fp_register_operand" "")
-	(minus:DF
-	 (match_dup 0)
-	 (match_dup 3)))]
-  "TARGET_HARD_FLOAT && peep2_reg_dead_p(2, operands[0])"
-  [(set (match_dup 3)
-	(minus:DF  (mult:DF (match_dup 1)
-			    (match_dup 2))
-		   (match_dup 3)))]
-  )
-
-(define_insn "nmsubacdf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(minus:DF  (neg:DF (mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-                                    (match_operand:DF 2 "avr32_fp_register_operand" "f")))
-                   (match_operand:DF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fnmsc.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "nmacdf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(plus:DF  (neg:DF (mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-                                   (match_operand:DF 2 "avr32_fp_register_operand" "f")))
-                  (match_operand:DF 3 "avr32_fp_register_operand" "0")))]
-  "TARGET_HARD_FLOAT"
-  "fnmac.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_peephole2
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "")
-	(mult:DF (match_operand:DF 1 "avr32_fp_register_operand" "")
-		 (match_operand:DF 2 "avr32_fp_register_operand" "")))
-   (set (match_operand:DF          3 "avr32_fp_register_operand" "")
-	(minus:DF
-	 (match_dup 3)
-	 (match_dup 0)))]
-  "TARGET_HARD_FLOAT && peep2_reg_dead_p(2, operands[0])"
-  [(set (match_dup 3)
-	(plus:DF  (neg:DF (mult:DF (match_dup 1)
-                                   (match_dup 2)))
-                  (match_dup 3)))]
-)
-
-(define_insn "adddf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(plus:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-		 (match_operand:DF 2 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fadd.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "subdf3"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(minus:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")
-                  (match_operand:DF 2 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fsub.d\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmul")])
-
-(define_insn "negdf2"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(neg:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fneg.d\t%0, %1"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmv")])
-
-(define_insn "absdf2"
-  [(set (match_operand:DF          0 "avr32_fp_register_operand" "=f")
-	(abs:DF (match_operand:DF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  "fabs.d\t%0, %1"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmv")])
-
-
-(define_expand "cmpdf"
-  [(set (cc0)
-	(compare:DF
-	 (match_operand:DF 0 "general_operand" "")
-	 (match_operand:DF 1 "general_operand"  "")))]
-  "TARGET_HARD_FLOAT"
-  "{
-   rtx tmpreg;
-   if ( !REG_P(operands[0]) )
-     operands[0] = force_reg(DFmode, operands[0]);
-
-   if ( !REG_P(operands[1]) )
-     operands[1] = force_reg(DFmode, operands[1]);
-
-   avr32_compare_op0 = operands[0];
-   avr32_compare_op1 = operands[1];
-
-   emit_insn(gen_cmpdf_internal(operands[0], operands[1]));
-
-   tmpreg = gen_reg_rtx(SImode);
-   emit_insn(gen_fpcc_to_reg(tmpreg));
-   emit_insn(gen_reg_to_cc(tmpreg));
-
-   DONE;
-  }"
-)
-
-(define_insn "cmpdf_internal"
-  [(set (reg:CC FPCC_REGNUM)
-	(compare:CC
-	 (match_operand:DF 0 "avr32_fp_register_operand" "f")
-	 (match_operand:DF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  {
-   if (!rtx_equal_p(cc_prev_status.mdep.fpvalue, SET_SRC(PATTERN (insn))) )
-      return "fcmp.d\t%0, %1";
-   return "";
-  }
-  [(set_attr "length" "4")
-   (set_attr "type" "fcmpd")
-   (set_attr "cc" "fpcompare")])
-
-(define_expand "cmpsf"
-  [(set (cc0)
-	(compare:SF
-	 (match_operand:SF 0 "general_operand" "")
-	 (match_operand:SF 1 "general_operand"  "")))]
-  "TARGET_HARD_FLOAT"
-  "{
-   rtx tmpreg;
-   if ( !REG_P(operands[0]) )
-     operands[0] = force_reg(SFmode, operands[0]);
-
-   if ( !REG_P(operands[1]) )
-     operands[1] = force_reg(SFmode, operands[1]);
-
-   avr32_compare_op0 = operands[0];
-   avr32_compare_op1 = operands[1];
-
-   emit_insn(gen_cmpsf_internal(operands[0], operands[1]));
-
-   tmpreg = gen_reg_rtx(SImode);
-   emit_insn(gen_fpcc_to_reg(tmpreg));
-   emit_insn(gen_reg_to_cc(tmpreg));
-
-   DONE;
-  }"
-)
-
-(define_insn "cmpsf_internal"
-  [(set (reg:CC FPCC_REGNUM)
-	(compare:CC
-	 (match_operand:SF 0 "avr32_fp_register_operand" "f")
-	 (match_operand:SF 1 "avr32_fp_register_operand" "f")))]
-  "TARGET_HARD_FLOAT"
-  {
-   if (!rtx_equal_p(cc_prev_status.mdep.fpvalue, SET_SRC(PATTERN (insn))) )
-      return "fcmp.s\t%0, %1";
-   return "";
-  }
-  [(set_attr "length" "4")
-   (set_attr "type" "fcmps")
-   (set_attr "cc" "fpcompare")])
-
-(define_insn "fpcc_to_reg"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(unspec:SI [(reg:CC FPCC_REGNUM)]
-		   UNSPEC_FPCC_TO_REG))]
-  "TARGET_HARD_FLOAT"
-  "fmov.s\t%0, fsr"
-  [(set_attr "length" "4")
-   (set_attr "type" "fmvcpu")])
-
-(define_insn "reg_to_cc"
-  [(set (cc0)
-	(unspec:SI [(match_operand:SI 0 "register_operand" "r")]
-		   UNSPEC_REG_TO_CC))]
-  "TARGET_HARD_FLOAT"
-  "musfr\t%0"
-  [(set_attr "length" "2")
-   (set_attr "type" "alu")
-   (set_attr "cc" "from_fpcc")])
-
-(define_insn "stm_fp"
-  [(unspec [(match_operand 0 "register_operand" "r")
-            (match_operand 1 "const_int_operand" "")
-            (match_operand 2 "const_int_operand" "")]
-	   UNSPEC_STMFP)]
-  "TARGET_HARD_FLOAT"
-  {
-    int cop_reglist = INTVAL(operands[1]);
-
-    if (INTVAL(operands[2]) != 0)
-      return "stcm.w\tcp0, --%0, %C1";
-    else
-      return "stcm.w\tcp0, %0, %C1";
-
-    if ( cop_reglist & ~0xff ){
-      operands[1] = GEN_INT(cop_reglist & ~0xff);
-      if (INTVAL(operands[2]) != 0)
-         return "stcm.d\tcp0, --%0, %D1";
-      else
-         return "stcm.d\tcp0, %0, %D1";
-    }
-  }
-  [(set_attr "type" "fstm")
-   (set_attr "length" "4")
-   (set_attr "cc" "none")])
diff -Naur ./gcc/config/avr32/predicates.md ./gcc/config/avr32/predicates.md
--- ./gcc/config/avr32/predicates.md	2010-12-02 11:56:23.000000000 -0600
+++ ./gcc/config/avr32/predicates.md	2010-12-02 12:02:34.000000000 -0600
@@ -308,11 +308,6 @@
        (match_test "(INTVAL(op) == 0) || (INTVAL(op) == 8)
                     || (INTVAL(op) == 16) || (INTVAL(op) == 24)")))
 
-;; True if this is a floating-point register.
-(define_predicate "avr32_fp_register_operand"
-  (and (match_operand 0 "register_operand")
-       (match_test "REGNO_REG_CLASS(REGNO(op)) == FP_REGS")))
-
 ;; True if this is a valid avr32 symbol operand.
 (define_predicate "avr32_symbol_operand"
    (and (match_code "label_ref, symbol_ref, const")
@@ -417,3 +412,11 @@
 (define_predicate "avr32_non_rmw_nonimmediate_operand"
   (and (not (match_operand 0 "avr32_rmw_memory_operand"))
        (match_operand 0 "nonimmediate_operand")))
+
+;; Return true if the operand is the 1.0f constant.
+
+(define_predicate "const_1f_operand"
+  (match_code "const_int,const_double")
+{
+  return (op == CONST1_RTX (SFmode));
+})
diff -Naur ./gcc/config/avr32/t-avr32 ./gcc/config/avr32/t-avr32
--- ./gcc/config/avr32/t-avr32	2010-12-02 12:02:06.000000000 -0600
+++ ./gcc/config/avr32/t-avr32	2010-12-02 12:02:34.000000000 -0600
@@ -1,7 +1,6 @@
 
 MD_INCLUDES= 	$(srcdir)/config/avr32/avr32.md \
 		$(srcdir)/config/avr32/sync.md \
-		$(srcdir)/config/avr32/fpcp.md \
 		$(srcdir)/config/avr32/simd.md \
         $(srcdir)/config/avr32/predicates.md
 
diff -Naur ./gcc/config/avr32/t-avr32-linux ./gcc/config/avr32/t-avr32-linux
--- ./gcc/config/avr32/t-avr32-linux	2010-12-02 12:02:06.000000000 -0600
+++ ./gcc/config/avr32/t-avr32-linux	2010-12-02 12:02:34.000000000 -0600
@@ -1,7 +1,6 @@
 
 MD_INCLUDES= 	$(srcdir)/config/avr32/avr32.md \
 		$(srcdir)/config/avr32/sync.md \
-		$(srcdir)/config/avr32/fpcp.md \
 		$(srcdir)/config/avr32/simd.md \
 		$(srcdir)/config/avr32/predicates.md
 
diff -Naur ./gcc/config/avr32/uc3fpu.md ./gcc/config/avr32/uc3fpu.md
--- ./gcc/config/avr32/uc3fpu.md	1969-12-31 18:00:00.000000000 -0600
+++ ./gcc/config/avr32/uc3fpu.md	2010-12-02 12:02:34.000000000 -0600
@@ -0,0 +1,198 @@
+;;   AVR32 machine description file for Floating-Point instructions.
+;;   Copyright 2003-2006 Atmel Corporation.
+;;
+;;
+;;   This file is part of GCC.
+;;
+;;   This program is free software; you can redistribute it and/or modify
+;;   it under the terms of the GNU General Public License as published by
+;;   the Free Software Foundation; either version 2 of the License, or
+;;   (at your option) any later version.
+;;
+;;   This program is distributed in the hope that it will be useful,
+;;   but WITHOUT ANY WARRANTY; without even the implied warranty of
+;;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;   GNU General Public License for more details.
+;;
+;;   You should have received a copy of the GNU General Public License
+;;   along with this program; if not, write to the Free Software
+;;   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+(define_insn "*movsf_uc3fp"
+  [(set (match_operand:SF 0 "nonimmediate_operand"     "=r,r,r,m")
+	(match_operand:SF 1 "general_operand"          "r,G,m,r"))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "@
+   mov\t%0, %1
+   mov\t%0, %1
+   ld.w\t%0, %1
+   st.w\t%0, %1"
+  [(set_attr "length" "2,4,4,4")
+   (set_attr "type" "alu,alu,load,store")])
+
+(define_insn "mulsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(mult:SF (match_operand:SF 1 "register_operand" "r")
+		 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fmul.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "nmulsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(neg:SF (mult:SF (match_operand:SF 1 "register_operand" "%r")
+                         (match_operand:SF 2 "register_operand" "r"))))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fnmul.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "macsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(plus:SF (mult:SF (match_operand:SF 1 "register_operand" "r")
+                          (match_operand:SF 2 "register_operand" "r"))
+                 (match_operand:SF 3 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fmac.s\t%0, %3, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+;(define_insn "nmacsf3"
+;  [(set (match_operand:SF          0 "register_operand" "=r")
+;	(plus:SF  (neg:SF (match_operand:SF 1 "register_operand" "r"))
+;                            (mult:SF(match_operand:SF 2 "register_operand" "r")
+;                                    (match_operand:SF 3 "register_operand" "r"))))]
+;  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+;  "fnmac.s\t%0, %1, %2, %3"
+;  [(set_attr "length" "4")
+;   (set_attr "type" "fmul")])
+
+(define_insn "nmacsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF  (mult:SF (match_operand:SF 2 "register_operand" "r")
+                        (match_operand:SF 3 "register_operand" "r"))
+	                    (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fnmac.s\t%0, %1, %2, %3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "msubacsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF (match_operand:SF 3 "register_operand" "r")
+	          (mult:SF (match_operand:SF 1 "register_operand" "r")
+                       (match_operand:SF 2 "register_operand" "r"))))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fmsc.s\t%0, %3, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "nmsubacsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF  (neg:SF (mult:SF (match_operand:SF 1 "register_operand" "r")
+                                    (match_operand:SF 2 "register_operand" "r")))
+                   (match_operand:SF 3 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fnmsc.s\t%0, %3, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "addsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(plus:SF (match_operand:SF 1 "register_operand" "%r")
+                   (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fadd.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "subsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF (match_operand:SF 1 "register_operand" "r")
+                  (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fsub.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "fixuns_truncsfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unsigned_fix:SI (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastrs.uw\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "fix_truncsfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(fix:SI (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastrs.sw\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "floatunssisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (unsigned_float:SF (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastuw.s\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "floatsisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (float:SF (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastsw.s\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "cmpsf_internal_uc3fp"
+  [(set (cc0)
+        (compare:CC
+         (match_operand:SF 0 "register_operand" "r")
+         (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  {
+   if (!rtx_equal_p(cc_prev_status.mdep.value, SET_SRC(PATTERN (insn))) )
+      return "fcmp.s\t%0, %1";
+   return "";
+  }
+  [(set_attr "length" "4")
+   (set_attr "cc" "compare")])
+
+(define_expand "divsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(div:SF (match_operand:SF 1 "register_operand" "r")
+		 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations"
+  "{
+    emit_insn(gen_frcpa_internal(operands[0],operands[2]));
+    emit_insn(gen_mulsf3(operands[0],operands[0],operands[1]));
+    DONE;
+  }"  
+)
+
+(define_insn "frcpa_internal"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(unspec:SF [(match_operand:SF 1 "register_operand" "r")] UNSPEC_FRCPA))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "frcpa.s %0,%1"
+  [(set_attr "length" "4")])
+
+(define_expand "sqrtsf2"
+  [(set (match_operand:SF 0 "register_operand" "")
+	(sqrt:SF (match_operand:SF 1 "register_operand" "")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations"
+  "
+{
+  rtx scratch = gen_reg_rtx (SFmode);
+  emit_insn (gen_rsqrtsf2 (scratch, operands[1], CONST1_RTX (SFmode)));
+  emit_insn (gen_divsf3(operands[0], force_reg (SFmode, CONST1_RTX (SFmode)),
+			 scratch));
+  DONE;
+}")
+
+(define_insn "rsqrtsf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(div:SF (match_operand:SF 2 "const_1f_operand" "F")
+		(sqrt:SF (match_operand:SF 1 "register_operand" "?r"))))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "frsqrta.s %1, %0")
